"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dexie-react-hooks";
exports.ids = ["vendor-chunks/dexie-react-hooks"];
exports.modules = {

/***/ "(ssr)/./node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDocument: () => (/* binding */ useDocument),\n/* harmony export */   useLiveQuery: () => (/* binding */ useLiveQuery),\n/* harmony export */   useObservable: () => (/* binding */ useObservable),\n/* harmony export */   usePermissions: () => (/* binding */ usePermissions)\n/* harmony export */ });\n/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ \"(ssr)/./node_modules/dexie/import-wrapper.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\nfunction useObservable(observableFactory, arg2, arg3) {\n    // Resolve vars from overloading variants of this function:\n    var deps;\n    var defaultResult;\n    if (typeof observableFactory === 'function') {\n        deps = arg2 || [];\n        defaultResult = arg3;\n    }\n    else {\n        deps = [];\n        defaultResult = arg2;\n    }\n    // Create a ref that keeps the state we need\n    var monitor = react__WEBPACK_IMPORTED_MODULE_1__.useRef({\n        hasResult: false,\n        result: defaultResult,\n        error: null,\n    });\n    // We control when component should rerender. Make triggerUpdate\n    // as examplified on React's docs at:\n    // https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate\n    var _a = react__WEBPACK_IMPORTED_MODULE_1__.useReducer(function (x) { return x + 1; }, 0); _a[0]; var triggerUpdate = _a[1];\n    // Memoize the observable based on deps\n    var observable = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(function () {\n        // Make it remember previous subscription's default value when\n        // resubscribing.\n        var observable = typeof observableFactory === 'function'\n            ? observableFactory()\n            : observableFactory;\n        if (!observable || typeof observable.subscribe !== 'function') {\n            if (observableFactory === observable) {\n                throw new TypeError(\"Given argument to useObservable() was neither a valid observable nor a function.\");\n            }\n            else {\n                throw new TypeError(\"Observable factory given to useObservable() did not return a valid observable.\");\n            }\n        }\n        if (!monitor.current.hasResult &&\n            typeof window !== 'undefined' // Don't do this in SSR\n        ) {\n            // Optimize for BehaviorSubject and other observables implementing getValue():\n            if (typeof observable.hasValue !== 'function' || observable.hasValue()) {\n                if (typeof observable.getValue === 'function') {\n                    monitor.current.result = observable.getValue();\n                    monitor.current.hasResult = true;\n                }\n                else {\n                    // Find out if the observable has a current value: try get it by subscribing and\n                    // unsubscribing synchronously\n                    var subscription = observable.subscribe(function (val) {\n                        monitor.current.result = val;\n                        monitor.current.hasResult = true;\n                    });\n                    // Unsubscribe directly. We only needed any synchronous value if it was possible.\n                    if (typeof subscription === 'function') {\n                        subscription();\n                    }\n                    else {\n                        subscription.unsubscribe();\n                    }\n                }\n            }\n        }\n        return observable;\n    }, deps);\n    // Integrate with react devtools:\n    react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue(monitor.current.result);\n    // Subscribe to the observable\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n        var subscription = observable.subscribe(function (val) {\n            var current = monitor.current;\n            if (current.error !== null || current.result !== val) {\n                current.error = null;\n                current.result = val;\n                current.hasResult = true;\n                triggerUpdate();\n            }\n        }, function (err) {\n            var current = monitor.current;\n            if (current.error !== err) {\n                current.error = err;\n                triggerUpdate();\n            }\n        });\n        return typeof subscription === 'function'\n            ? subscription // Support observables that return unsubscribe directly\n            : subscription.unsubscribe.bind(subscription);\n    }, deps);\n    // Throw if observable has emitted error so that\n    // an ErrorBoundrary can catch it\n    if (monitor.current.error)\n        throw monitor.current.error;\n    // Return the current result\n    return monitor.current.result;\n}\n\nfunction useLiveQuery(querier, deps, defaultResult) {\n    return useObservable(function () { return dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie.liveQuery(querier); }, deps || [], defaultResult);\n}\n\nfunction usePermissions(firstArg, table, obj) {\n    if (!firstArg)\n        throw new TypeError(\"Invalid arguments to usePermissions(): undefined or null\");\n    var db;\n    if (arguments.length >= 3) {\n        if (!('transaction' in firstArg)) {\n            // Using ducktyping instead of instanceof in case there are multiple Dexie modules in app.\n            // First arg is  ensures first arg is a Dexie instance\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 1st arg must be a Dexie instance\");\n        }\n        if (typeof table !== 'string')\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 2nd arg must be string\");\n        if (!obj || typeof obj !== 'object')\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): 3rd arg must be an object\");\n        db = firstArg;\n    }\n    else {\n        if (firstArg instanceof dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie)\n            throw new TypeError(\"Invalid arguments to usePermission(db, table, obj): Missing table and obj arguments.\");\n        if (typeof firstArg.table === 'function' &&\n            typeof firstArg.db === 'object') {\n            db = firstArg.db;\n            obj = firstArg;\n            table = firstArg.table();\n        }\n        else {\n            throw new TypeError(\"Invalid arguments to usePermissions(). \" +\n                \"Expected usePermissions(entity: DexieCloudEntity) or \" +\n                \"usePermissions(db: Dexie, table: string, obj: DexieCloudObject)\");\n        }\n    }\n    if (!('cloud' in db))\n        throw new Error(\"usePermissions() is only for Dexie Cloud but there's no dexie-cloud-addon active in given db.\");\n    if (!('permissions' in db.cloud))\n        throw new Error(\"usePermissions() requires a newer version of dexie-cloud-addon. Please upgrade it.\");\n    return useObservable(\n    // @ts-ignore\n    function () { return db.cloud.permissions(obj, table); }, [obj.realmId, obj.owner, table]);\n}\n\nvar gracePeriod = 100; // 100 ms = grace period to optimize for unload/reload scenarios\nvar fr = typeof FinalizationRegistry !== 'undefined' && new FinalizationRegistry(function (doc) {\n    // If coming here, react effect never ran. This is a fallback cleanup mechanism.\n    var DexieYProvider = dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie['DexieYProvider'];\n    if (DexieYProvider)\n        DexieYProvider.release(doc);\n});\nfunction useDocument(doc) {\n    var _a, _b;\n    if (!fr)\n        throw new TypeError('FinalizationRegistry not supported.');\n    var providerRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    var DexieYProvider = dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie['DexieYProvider'];\n    if (!DexieYProvider) {\n        throw new Error('DexieYProvider is not available. Make sure `y-dexie` is installed and imported.');\n    }\n    var unregisterToken = undefined;\n    if (doc) {\n        if (doc !== ((_a = providerRef.current) === null || _a === void 0 ? void 0 : _a.doc)) {\n            providerRef.current = DexieYProvider.load(doc, { gracePeriod: gracePeriod });\n            unregisterToken = Object.create(null);\n            fr.register(providerRef, doc, unregisterToken);\n        }\n    }\n    else if ((_b = providerRef.current) === null || _b === void 0 ? void 0 : _b.doc) {\n        providerRef.current = null;\n    }\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n        if (doc) {\n            // Doc is set or changed. Unregister provider from FinalizationRegistry\n            // and instead take over from here to release the doc when component is unmounted\n            // or when doc is changed. What we're doing here is to avoid relying on FinalizationRegistry\n            // in all the normal cases and instead rely on React's lifecycle to release the doc.\n            // But there can be situations when react never calls this effect and therefore, we\n            // need to rely on FinalizationRegistry to release the doc as a fallback.\n            // We cannot wait with loading the document until the effect happens, because the doc\n            // could have been destroyed in the meantime.\n            if (unregisterToken)\n                fr.unregister(unregisterToken);\n            var provider = DexieYProvider.for(doc);\n            if (provider) {\n                return function () {\n                    DexieYProvider.release(doc);\n                };\n            }\n            else {\n                // Maybe the doc was destroyed in the meantime.\n                // Can not happen if React and FinalizationRegistry works as we expect them to.\n                // Except if a user had called DexieYProvider.release() on the doc\n                throw new Error(\"FATAL. DexieYProvider.release() has been called somewhere in application code, making us lose the document.\");\n            }\n        }\n    }, [doc, unregisterToken]);\n    return providerRef.current;\n}\n\n\n//# sourceMappingURL=dexie-react-hooks.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGV4aWUtcmVhY3QtaG9va3MvZGlzdC9kZXhpZS1yZWFjdC1ob29rcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQThCO0FBQ0o7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZDQUFnQixnQkFBZ0IsZUFBZSxNQUFNLE9BQU87QUFDekU7QUFDQSxxQkFBcUIsMENBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksZ0RBQW1CO0FBQ3ZCO0FBQ0EsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLE9BQU8sd0NBQUssc0JBQXNCO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMENBQTBDO0FBQzVEOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EseUJBQXlCLHdDQUFLO0FBQzlCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUNBQVk7QUFDbEMseUJBQXlCLHdDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVvRTtBQUNwRSIsInNvdXJjZXMiOlsid2VicGFjazovL2J1ZGdldC1wbGFubmVyLy4vbm9kZV9tb2R1bGVzL2RleGllLXJlYWN0LWhvb2tzL2Rpc3QvZGV4aWUtcmVhY3QtaG9va3MubWpzP2ZiNDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICdkZXhpZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiB1c2VPYnNlcnZhYmxlKG9ic2VydmFibGVGYWN0b3J5LCBhcmcyLCBhcmczKSB7XG4gICAgLy8gUmVzb2x2ZSB2YXJzIGZyb20gb3ZlcmxvYWRpbmcgdmFyaWFudHMgb2YgdGhpcyBmdW5jdGlvbjpcbiAgICB2YXIgZGVwcztcbiAgICB2YXIgZGVmYXVsdFJlc3VsdDtcbiAgICBpZiAodHlwZW9mIG9ic2VydmFibGVGYWN0b3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRlcHMgPSBhcmcyIHx8IFtdO1xuICAgICAgICBkZWZhdWx0UmVzdWx0ID0gYXJnMztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlcHMgPSBbXTtcbiAgICAgICAgZGVmYXVsdFJlc3VsdCA9IGFyZzI7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIHJlZiB0aGF0IGtlZXBzIHRoZSBzdGF0ZSB3ZSBuZWVkXG4gICAgdmFyIG1vbml0b3IgPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBoYXNSZXN1bHQ6IGZhbHNlLFxuICAgICAgICByZXN1bHQ6IGRlZmF1bHRSZXN1bHQsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgIH0pO1xuICAgIC8vIFdlIGNvbnRyb2wgd2hlbiBjb21wb25lbnQgc2hvdWxkIHJlcmVuZGVyLiBNYWtlIHRyaWdnZXJVcGRhdGVcbiAgICAvLyBhcyBleGFtcGxpZmllZCBvbiBSZWFjdCdzIGRvY3MgYXQ6XG4gICAgLy8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLWZhcS5odG1sI2lzLXRoZXJlLXNvbWV0aGluZy1saWtlLWZvcmNldXBkYXRlXG4gICAgdmFyIF9hID0gUmVhY3QudXNlUmVkdWNlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCArIDE7IH0sIDApOyBfYVswXTsgdmFyIHRyaWdnZXJVcGRhdGUgPSBfYVsxXTtcbiAgICAvLyBNZW1vaXplIHRoZSBvYnNlcnZhYmxlIGJhc2VkIG9uIGRlcHNcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBNYWtlIGl0IHJlbWVtYmVyIHByZXZpb3VzIHN1YnNjcmlwdGlvbidzIGRlZmF1bHQgdmFsdWUgd2hlblxuICAgICAgICAvLyByZXN1YnNjcmliaW5nLlxuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IHR5cGVvZiBvYnNlcnZhYmxlRmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBvYnNlcnZhYmxlRmFjdG9yeSgpXG4gICAgICAgICAgICA6IG9ic2VydmFibGVGYWN0b3J5O1xuICAgICAgICBpZiAoIW9ic2VydmFibGUgfHwgdHlwZW9mIG9ic2VydmFibGUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YWJsZUZhY3RvcnkgPT09IG9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2l2ZW4gYXJndW1lbnQgdG8gdXNlT2JzZXJ2YWJsZSgpIHdhcyBuZWl0aGVyIGEgdmFsaWQgb2JzZXJ2YWJsZSBub3IgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JzZXJ2YWJsZSBmYWN0b3J5IGdpdmVuIHRvIHVzZU9ic2VydmFibGUoKSBkaWQgbm90IHJldHVybiBhIHZhbGlkIG9ic2VydmFibGUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbW9uaXRvci5jdXJyZW50Lmhhc1Jlc3VsdCAmJlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgLy8gRG9uJ3QgZG8gdGhpcyBpbiBTU1JcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgQmVoYXZpb3JTdWJqZWN0IGFuZCBvdGhlciBvYnNlcnZhYmxlcyBpbXBsZW1lbnRpbmcgZ2V0VmFsdWUoKTpcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2YWJsZS5oYXNWYWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYnNlcnZhYmxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ic2VydmFibGUuZ2V0VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvci5jdXJyZW50LnJlc3VsdCA9IG9ic2VydmFibGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvci5jdXJyZW50Lmhhc1Jlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIG91dCBpZiB0aGUgb2JzZXJ2YWJsZSBoYXMgYSBjdXJyZW50IHZhbHVlOiB0cnkgZ2V0IGl0IGJ5IHN1YnNjcmliaW5nIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB1bnN1YnNjcmliaW5nIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbml0b3IuY3VycmVudC5yZXN1bHQgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb25pdG9yLmN1cnJlbnQuaGFzUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc3Vic2NyaWJlIGRpcmVjdGx5LiBXZSBvbmx5IG5lZWRlZCBhbnkgc3luY2hyb25vdXMgdmFsdWUgaWYgaXQgd2FzIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9LCBkZXBzKTtcbiAgICAvLyBJbnRlZ3JhdGUgd2l0aCByZWFjdCBkZXZ0b29sczpcbiAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKG1vbml0b3IuY3VycmVudC5yZXN1bHQpO1xuICAgIC8vIFN1YnNjcmliZSB0byB0aGUgb2JzZXJ2YWJsZVxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZShmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG1vbml0b3IuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmVycm9yICE9PSBudWxsIHx8IGN1cnJlbnQucmVzdWx0ICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnJlc3VsdCA9IHZhbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Lmhhc1Jlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG1vbml0b3IuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmVycm9yICE9PSBlcnIpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3Vic2NyaXB0aW9uID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHN1YnNjcmlwdGlvbiAvLyBTdXBwb3J0IG9ic2VydmFibGVzIHRoYXQgcmV0dXJuIHVuc3Vic2NyaWJlIGRpcmVjdGx5XG4gICAgICAgICAgICA6IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZS5iaW5kKHN1YnNjcmlwdGlvbik7XG4gICAgfSwgZGVwcyk7XG4gICAgLy8gVGhyb3cgaWYgb2JzZXJ2YWJsZSBoYXMgZW1pdHRlZCBlcnJvciBzbyB0aGF0XG4gICAgLy8gYW4gRXJyb3JCb3VuZHJhcnkgY2FuIGNhdGNoIGl0XG4gICAgaWYgKG1vbml0b3IuY3VycmVudC5lcnJvcilcbiAgICAgICAgdGhyb3cgbW9uaXRvci5jdXJyZW50LmVycm9yO1xuICAgIC8vIFJldHVybiB0aGUgY3VycmVudCByZXN1bHRcbiAgICByZXR1cm4gbW9uaXRvci5jdXJyZW50LnJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdXNlTGl2ZVF1ZXJ5KHF1ZXJpZXIsIGRlcHMsIGRlZmF1bHRSZXN1bHQpIHtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZShmdW5jdGlvbiAoKSB7IHJldHVybiBEZXhpZS5saXZlUXVlcnkocXVlcmllcik7IH0sIGRlcHMgfHwgW10sIGRlZmF1bHRSZXN1bHQpO1xufVxuXG5mdW5jdGlvbiB1c2VQZXJtaXNzaW9ucyhmaXJzdEFyZywgdGFibGUsIG9iaikge1xuICAgIGlmICghZmlyc3RBcmcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyB0byB1c2VQZXJtaXNzaW9ucygpOiB1bmRlZmluZWQgb3IgbnVsbFwiKTtcbiAgICB2YXIgZGI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgICAgICBpZiAoISgndHJhbnNhY3Rpb24nIGluIGZpcnN0QXJnKSkge1xuICAgICAgICAgICAgLy8gVXNpbmcgZHVja3R5cGluZyBpbnN0ZWFkIG9mIGluc3RhbmNlb2YgaW4gY2FzZSB0aGVyZSBhcmUgbXVsdGlwbGUgRGV4aWUgbW9kdWxlcyBpbiBhcHAuXG4gICAgICAgICAgICAvLyBGaXJzdCBhcmcgaXMgIGVuc3VyZXMgZmlyc3QgYXJnIGlzIGEgRGV4aWUgaW5zdGFuY2VcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyB0byB1c2VQZXJtaXNzaW9uKGRiLCB0YWJsZSwgb2JqKTogMXN0IGFyZyBtdXN0IGJlIGEgRGV4aWUgaW5zdGFuY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgdG8gdXNlUGVybWlzc2lvbihkYiwgdGFibGUsIG9iaik6IDJuZCBhcmcgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIHRvIHVzZVBlcm1pc3Npb24oZGIsIHRhYmxlLCBvYmopOiAzcmQgYXJnIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgICBkYiA9IGZpcnN0QXJnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZpcnN0QXJnIGluc3RhbmNlb2YgRGV4aWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgdG8gdXNlUGVybWlzc2lvbihkYiwgdGFibGUsIG9iaik6IE1pc3NpbmcgdGFibGUgYW5kIG9iaiBhcmd1bWVudHMuXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZpcnN0QXJnLnRhYmxlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICB0eXBlb2YgZmlyc3RBcmcuZGIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYiA9IGZpcnN0QXJnLmRiO1xuICAgICAgICAgICAgb2JqID0gZmlyc3RBcmc7XG4gICAgICAgICAgICB0YWJsZSA9IGZpcnN0QXJnLnRhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgdG8gdXNlUGVybWlzc2lvbnMoKS4gXCIgK1xuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdXNlUGVybWlzc2lvbnMoZW50aXR5OiBEZXhpZUNsb3VkRW50aXR5KSBvciBcIiArXG4gICAgICAgICAgICAgICAgXCJ1c2VQZXJtaXNzaW9ucyhkYjogRGV4aWUsIHRhYmxlOiBzdHJpbmcsIG9iajogRGV4aWVDbG91ZE9iamVjdClcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEoJ2Nsb3VkJyBpbiBkYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVzZVBlcm1pc3Npb25zKCkgaXMgb25seSBmb3IgRGV4aWUgQ2xvdWQgYnV0IHRoZXJlJ3Mgbm8gZGV4aWUtY2xvdWQtYWRkb24gYWN0aXZlIGluIGdpdmVuIGRiLlwiKTtcbiAgICBpZiAoISgncGVybWlzc2lvbnMnIGluIGRiLmNsb3VkKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXNlUGVybWlzc2lvbnMoKSByZXF1aXJlcyBhIG5ld2VyIHZlcnNpb24gb2YgZGV4aWUtY2xvdWQtYWRkb24uIFBsZWFzZSB1cGdyYWRlIGl0LlwiKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZShcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIuY2xvdWQucGVybWlzc2lvbnMob2JqLCB0YWJsZSk7IH0sIFtvYmoucmVhbG1JZCwgb2JqLm93bmVyLCB0YWJsZV0pO1xufVxuXG52YXIgZ3JhY2VQZXJpb2QgPSAxMDA7IC8vIDEwMCBtcyA9IGdyYWNlIHBlcmlvZCB0byBvcHRpbWl6ZSBmb3IgdW5sb2FkL3JlbG9hZCBzY2VuYXJpb3NcbnZhciBmciA9IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uIChkb2MpIHtcbiAgICAvLyBJZiBjb21pbmcgaGVyZSwgcmVhY3QgZWZmZWN0IG5ldmVyIHJhbi4gVGhpcyBpcyBhIGZhbGxiYWNrIGNsZWFudXAgbWVjaGFuaXNtLlxuICAgIHZhciBEZXhpZVlQcm92aWRlciA9IERleGllWydEZXhpZVlQcm92aWRlciddO1xuICAgIGlmIChEZXhpZVlQcm92aWRlcilcbiAgICAgICAgRGV4aWVZUHJvdmlkZXIucmVsZWFzZShkb2MpO1xufSk7XG5mdW5jdGlvbiB1c2VEb2N1bWVudChkb2MpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghZnIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpbmFsaXphdGlvblJlZ2lzdHJ5IG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgdmFyIHByb3ZpZGVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBEZXhpZVlQcm92aWRlciA9IERleGllWydEZXhpZVlQcm92aWRlciddO1xuICAgIGlmICghRGV4aWVZUHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXhpZVlQcm92aWRlciBpcyBub3QgYXZhaWxhYmxlLiBNYWtlIHN1cmUgYHktZGV4aWVgIGlzIGluc3RhbGxlZCBhbmQgaW1wb3J0ZWQuJyk7XG4gICAgfVxuICAgIHZhciB1bnJlZ2lzdGVyVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgaWYgKGRvYykge1xuICAgICAgICBpZiAoZG9jICE9PSAoKF9hID0gcHJvdmlkZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvYykpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyUmVmLmN1cnJlbnQgPSBEZXhpZVlQcm92aWRlci5sb2FkKGRvYywgeyBncmFjZVBlcmlvZDogZ3JhY2VQZXJpb2QgfSk7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyVG9rZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZnIucmVnaXN0ZXIocHJvdmlkZXJSZWYsIGRvYywgdW5yZWdpc3RlclRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgoX2IgPSBwcm92aWRlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZG9jKSB7XG4gICAgICAgIHByb3ZpZGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICAvLyBEb2MgaXMgc2V0IG9yIGNoYW5nZWQuIFVucmVnaXN0ZXIgcHJvdmlkZXIgZnJvbSBGaW5hbGl6YXRpb25SZWdpc3RyeVxuICAgICAgICAgICAgLy8gYW5kIGluc3RlYWQgdGFrZSBvdmVyIGZyb20gaGVyZSB0byByZWxlYXNlIHRoZSBkb2Mgd2hlbiBjb21wb25lbnQgaXMgdW5tb3VudGVkXG4gICAgICAgICAgICAvLyBvciB3aGVuIGRvYyBpcyBjaGFuZ2VkLiBXaGF0IHdlJ3JlIGRvaW5nIGhlcmUgaXMgdG8gYXZvaWQgcmVseWluZyBvbiBGaW5hbGl6YXRpb25SZWdpc3RyeVxuICAgICAgICAgICAgLy8gaW4gYWxsIHRoZSBub3JtYWwgY2FzZXMgYW5kIGluc3RlYWQgcmVseSBvbiBSZWFjdCdzIGxpZmVjeWNsZSB0byByZWxlYXNlIHRoZSBkb2MuXG4gICAgICAgICAgICAvLyBCdXQgdGhlcmUgY2FuIGJlIHNpdHVhdGlvbnMgd2hlbiByZWFjdCBuZXZlciBjYWxscyB0aGlzIGVmZmVjdCBhbmQgdGhlcmVmb3JlLCB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byByZWx5IG9uIEZpbmFsaXphdGlvblJlZ2lzdHJ5IHRvIHJlbGVhc2UgdGhlIGRvYyBhcyBhIGZhbGxiYWNrLlxuICAgICAgICAgICAgLy8gV2UgY2Fubm90IHdhaXQgd2l0aCBsb2FkaW5nIHRoZSBkb2N1bWVudCB1bnRpbCB0aGUgZWZmZWN0IGhhcHBlbnMsIGJlY2F1c2UgdGhlIGRvY1xuICAgICAgICAgICAgLy8gY291bGQgaGF2ZSBiZWVuIGRlc3Ryb3llZCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgICAgICBpZiAodW5yZWdpc3RlclRva2VuKVxuICAgICAgICAgICAgICAgIGZyLnVucmVnaXN0ZXIodW5yZWdpc3RlclRva2VuKTtcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IERleGllWVByb3ZpZGVyLmZvcihkb2MpO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgRGV4aWVZUHJvdmlkZXIucmVsZWFzZShkb2MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYXliZSB0aGUgZG9jIHdhcyBkZXN0cm95ZWQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICAgICAgICAgIC8vIENhbiBub3QgaGFwcGVuIGlmIFJlYWN0IGFuZCBGaW5hbGl6YXRpb25SZWdpc3RyeSB3b3JrcyBhcyB3ZSBleHBlY3QgdGhlbSB0by5cbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgaWYgYSB1c2VyIGhhZCBjYWxsZWQgRGV4aWVZUHJvdmlkZXIucmVsZWFzZSgpIG9uIHRoZSBkb2NcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGQVRBTC4gRGV4aWVZUHJvdmlkZXIucmVsZWFzZSgpIGhhcyBiZWVuIGNhbGxlZCBzb21ld2hlcmUgaW4gYXBwbGljYXRpb24gY29kZSwgbWFraW5nIHVzIGxvc2UgdGhlIGRvY3VtZW50LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtkb2MsIHVucmVnaXN0ZXJUb2tlbl0pO1xuICAgIHJldHVybiBwcm92aWRlclJlZi5jdXJyZW50O1xufVxuXG5leHBvcnQgeyB1c2VEb2N1bWVudCwgdXNlTGl2ZVF1ZXJ5LCB1c2VPYnNlcnZhYmxlLCB1c2VQZXJtaXNzaW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV4aWUtcmVhY3QtaG9va3MubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs\n");

/***/ })

};
;